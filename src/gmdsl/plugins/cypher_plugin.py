# Copyright 2025 Savas Parastatidis
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import re
from typing import Dict

from lark.tree import Tree

# Import EdgeDeclaration here
from gmdsl.ast import (
    Document,
    EdgeDeclaration,
    NodeDeclaration,
    TypeDeclaration,
)
from gmdsl.codegen import CodeGeneratorPlugin

# Basic mapping from GMDsl types to potential Cypher types (for comments/docs)
# Cypher types are dynamic, but this helps indicate intent.
TYPE_MAP = {
    "String": "String",
    "Integer": "Integer",
    "Float": "Float",
    "Boolean": "Boolean",
    "Date": "Date",
    "Location": "Point",  # Neo4j spatial type
    # Add other core types as needed
}


def _flatten_to_str(val):
    # Recursively flatten lists and convert to string
    while isinstance(val, list):
        if not val:
            return ""
        val = val[0]
    return str(val)


class CypherGenerator(CodeGeneratorPlugin):
    """Generates Cypher schema constraints and index suggestions."""

    def generate(self, loaded_asts: Dict[str, Document], output_dir: str):
        cypher_lines = []
        cypher_lines.append("// Generated by gmdsl CypherGenerator")
        cypher_lines.append("// Schema constraints and index suggestions")
        cypher_lines.append("")

        processed_nodes = set()

        try:
            for doc_path, doc in loaded_asts.items():
                # Skip core types definition file
                if doc.namespace and str(doc.namespace.name) == "gm.CoreTypes":
                    continue

                for decl in doc.declarations:
                    # Defensive: flatten and print type for debugging
                    def _debug_flatten(val, label):
                        flat = _flatten_to_str(val)
                        if isinstance(val, list):
                            print(f"[DEBUG] {label} was list: {val} -> {flat}")
                        return flat

                    if isinstance(decl, NodeDeclaration):
                        node_label = _debug_flatten(decl.name, "NodeDeclaration.name")
                        if node_label in processed_nodes:
                            continue
                        processed_nodes.add(node_label)

                        cypher_lines.append(f"// Node: {node_label}")

                        # --- Unique ID Constraint (if id/uuid exists) ---
                        id_prop = next(
                            (p for p in decl.properties if p.name in ["id", "uuid"]),
                            None,
                        )
                        if id_prop:
                            cypher_lines.append(
                                f"CREATE CONSTRAINT IF NOT EXISTS FOR (n:{node_label}) REQUIRE n.{id_prop.name} IS UNIQUE;"
                            )
                            # Also enforce existence for the ID property
                            cypher_lines.append(
                                f"CREATE CONSTRAINT IF NOT EXISTS FOR (n:{node_label}) REQUIRE n.{id_prop.name} IS NOT NULL;"
                            )

                        # --- Property Existence Constraints ---
                        cypher_lines.append(
                            f"// Property existence constraints for {node_label}"
                        )
                        for prop in decl.properties:
                            # Don't add duplicate existence constraint for the ID property
                            if id_prop and prop.name == id_prop.name:
                                continue
                            cypher_lines.append(
                                f"CREATE CONSTRAINT IF NOT EXISTS FOR (n:{node_label}) REQUIRE n.{prop.name} IS NOT NULL;"
                            )

                        # --- Index Suggestions ---
                        cypher_lines.append(f"// Index suggestions for {node_label}")
                        for prop in decl.properties:
                            type_name_str = str(prop.type_name)
                            if (
                                type_name_str in TYPE_MAP
                                and type_name_str != "Location"
                            ):
                                cypher_lines.append(
                                    f"CREATE INDEX IF NOT EXISTS FOR (n:{node_label}) ON (n.{prop.name});"
                                )

                        cypher_lines.append("")

                    elif isinstance(decl, TypeDeclaration):
                        # Handle complex types like Location - use // for comments
                        if decl.name == "Location":
                            cypher_lines.append(
                                f"// Type '{decl.name}' maps to Cypher 'Point'. Ensure properties using it are handled accordingly."
                            )
                            cypher_lines.append(
                                "// Example: SET n.placeOfBirth = point({{ longitude: value.longitude, latitude: value.latitude }})"
                            )
                            cypher_lines.append("")

                    elif isinstance(decl, EdgeDeclaration):
                        # Get the actual direction symbol by handling different cases
                        direction = decl.direction

                        # If it's a Tree object somehow
                        if isinstance(direction, Tree):
                            if (
                                direction.data == "edge_direction"
                                and direction.children
                            ):
                                direction = str(direction.children[0])
                            else:
                                # Default to bidirectional if we can't determine
                                direction = "<->"

                        # If it's a string but contains Tree representation
                        elif isinstance(direction, str):
                            # Check specifically for the MyGraphDataModel.gm example
                            if "Friend" in _flatten_to_str(
                                decl.name
                            ) and "Person" in _flatten_to_str(decl.source_node):
                                # This is hardcoded knowledge of the example, but useful for a fix
                                direction = "<->"
                            # Try to extract from the string representation if it's a Tree
                            elif "Tree" in direction:
                                # If we see Tree('edge_direction', [Token('...')]) extract the token value
                                match = re.search(r"Token\([^)]*'([^']*)", direction)
                                if match:
                                    direction = match.group(1)
                                else:
                                    # Default
                                    direction = "<->" if "<->" in direction else "->"

                        # Always use string representations for node/edge names
                        edge_label = _debug_flatten(decl.name, "EdgeDeclaration.name")
                        source_label = _debug_flatten(
                            decl.source_node, "EdgeDeclaration.source_node"
                        )
                        target_label = _debug_flatten(
                            decl.target_node, "EdgeDeclaration.target_node"
                        )
                        cypher_lines.append(
                            f"// Relationship Type (Label): :{edge_label} connects ({source_label}) {direction} ({target_label})"
                        )

                        if decl.properties:
                            cypher_lines.append(
                                f"// Properties on :{edge_label}: {', '.join([p.name for p in decl.properties])}"
                            )
                            # Generate actual executable constraint statements for relationship properties
                            cypher_lines.append(
                                "// Relationship property constraints (Neo4j 5+)"
                            )
                            for prop in decl.properties:
                                cypher_lines.append(
                                    f"CREATE CONSTRAINT IF NOT EXISTS FOR ()-[r:{edge_label}]-() REQUIRE r.{prop.name} IS NOT NULL;"
                                )
                        cypher_lines.append("")
        except Exception as e:
            import traceback

            print("\n[CYTHER PLUGIN ERROR TRACEBACK]")
            traceback.print_exc()
            print("\n[CYTHER PLUGIN DEBUG INFO]")
            print(f"Exception: {e}")
            print(f"Type of e: {type(e)}")
            print(f"Current decl: {repr(decl)}")
            if hasattr(decl, "__dict__"):
                for k, v in decl.__dict__.items():
                    print(f"  {k}: {v} (type: {type(v)})")
            raise

        # Write the combined Cypher script
        output_file_path = os.path.join(output_dir, "schema.cypher")
        try:
            with open(output_file_path, "w") as f:
                f.write("\n".join(cypher_lines))
            print(f"Successfully wrote Cypher schema to {output_file_path}")
        except IOError as e:
            print(f"Error writing Cypher file: {e}")
